helfer = require 'helfer'

optionsToConfig = (options) ->
  config = {}

  # TODO better name for this
  config.tableWordArray =
    helfer.splitCamelcase (options.tableWords or 'table')

  config.nameToTable = options.nameToTable or (name) ->
    helfer.joinCamelcase helfer.splitCamelcase(name).concat(config.tableWordArray)

  return config

configure = (options = {}) ->
  config = optionsToConfig options
  sources = {}

###################################################################################
# table

  sources.table = (name) ->
    words = helfer.splitCamelcase name

    results = helfer.splitArrayWhereSequence words, config.tableWordArray

    containsTable = results.length is 2
    unless containsTable
      return
    doesntBeginWithTable = results[0]?.length isnt 0
    unless doesntBeginWithTable
      return
    endsWithTable = results[1]?.length is 0
    unless endsWithTable
      return

    tableName = helfer.joinUnderscore results[0]

    factory = (mesa) ->
      mesa.table(tableName)

    factory.__inject = ['mesa']
    factory.__source = 'generated by fragments-postgres.table'
    return factory


###################################################################################
# parse data select

  sources.parseSelect = (name) ->
    words = helfer.splitCamelcase name

    type = words[0]

    unless type in ['first', 'select']
      return

    tableWhereOrderConnection = words.slice(1)

    [tableWhereOrder, withConnection] = helfer.splitArrayWhereSequence(
      tableWhereOrderConnection
      ['with', 'connection']
    )

    [tableWhere, order...] = helfer.splitArrayWhereSequence(
      tableWhereOrder
      ['order', 'by']
    )

    [table, where...] = helfer.splitArrayWhereSequence tableWhere, 'where'

    if table.length is 0
      return

    whereProcessed = where
      .filter (x) -> x.length isnt 0
      .map helfer.joinUnderscore

    orderProcessed = order
      .filter (x) -> x.length isnt 0
      .map (x) ->
        last = x[x.length - 1]
        if last in ['asc', 'desc']
          column = x.slice(0, -1)
          direction = last.toUpperCase()
        else
          column = x
          direction = 'ASC'
        {
          column: helfer.joinUnderscore column
          direction: direction
        }

    {
      type: type
      name: helfer.joinCamelcase table
      order: orderProcessed
      where: whereProcessed
      withConnection: withConnection?
    }

###################################################################################
# select first

  sources.selectFirst = (name) ->
    parsed = sources.parseSelect name
    unless parsed? and parsed.type is 'first'
      return

    factory = (table) ->
      (args...) ->
        query = table
        index = 0
        parsed.where.forEach (x) ->
          condition = {}
          condition[x] = args[index++]
          query = query.where condition
        if parsed.order.length isnt 0
          order = parsed.order
            .map (x) ->
              x.column + ' ' + x.direction
            .join (', ')
          query = query.order order
        if parsed.withConnection
          connection = args[index]
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          query = query.setConnection connection

        query.first()

    factory.__inject = [
      config.nameToTable(parsed.name)
    ]
    factory.__source = 'generated by fragments-postgres.selectFirst'
    factory.__parsed = parsed
    return factory

###################################################################################
# select

  sources.select = (name) ->
    parsed = sources.parseSelect name
    unless parsed? and parsed.type is 'select'
      return

    factory = (table) ->
      (args...) ->
        q = table
        index = 0
        parsed.where.forEach (x) ->
          condition = {}
          condition[x] = args[index++]
          q = q.where condition
        if parsed.order.length isnt 0
          order = parsed.order
            .map (x) ->
              x.column + ' ' + x.direction
            .join (', ')
          q = q.order order
        if parsed.withConnection
          connection = args[index]
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          q = q.setConnection connection
        q.find()

    factory.__inject = [
      config.nameToTable(parsed.name)
    ]
    factory.__source = 'generated by fragments-postgres.select'
    factory.__parsed = parsed
    return factory

###################################################################################
# insert

  sources.parseInsert = (name) ->
    words = helfer.splitCamelcase name

    unless 'insert' is words[0]
      return

    [table, withConnection] = helfer.splitArrayWhereSequence(
      words.slice(1)
      ['with', 'connection']
    )

    if table.length is 0
      return

    {
      name: helfer.joinCamelcase(table)
      withConnection: withConnection?
    }

# module.exports.newDataInsertResolver = (options = {}) ->
#   options.nameToAllowedColumns ?= (name) ->
#     name + 'InsertableColumns'
#
#     match = options.matcher name
#     unless match?
#       return
#
#     factory = (table, allowedColumns) ->
#       (data, connection) ->
#         query = table
#         if match.withConnection
#           unless connection?
#             throw new Error "#{name} must be called with connection as argument number #{index+1}"
#           query = query.setConnection connection
#         query
#           .allow(allowedColumns)
#           .insert(data)
#
#     factory.$inject = [
#       options.nameToTable(match.name)
#       options.nameToAllowedColumns(match.name)
#     ]
#     factory.$source = 'autogenerated by fragments-forge.newDataInsertResolver'
#     factory.$match = match
#
#     return {
#       factory: factory
#       name: name
#     }
#
#   resolver.$name = 'dataInsertResolver'
#   return resolver

###################################################################################
# update

  sources.parseUpdate = (name) ->
    words = helfer.splitCamelcase name

    unless 'update' is words[0]
      return

    [tableWhere, withConnection] = helfer.splitArrayWhereSequence(
      words.slice(1)
      ['with', 'connection']
    )

    [table, where...] = helfer.splitArrayWhereSequence tableWhere, 'where'

    if table.length is 0
      return

    # dont allow mass update without condition for security reasons
    if where.length is 0
      return

    {
      name: helfer.joinCamelcase table
      where: where.map (x) -> helfer.joinUnderscore x
      withConnection: withConnection?
    }

# module.exports.updateSource = (options = {}) ->
#   options.matcher ?= module.exports.parseDataUpdate
#   options.nameToTable ?= (name) ->
#     name + 'Table'
#   options.nameToAllowedColumns ?= (name) ->
#     name + 'UpdateableColumns'
#
#   resolver = (name, container, inner) ->
#     result = inner name
#     if result?
#       return result
#
#     match = options.matcher name
#     unless match?
#       return
#
#     factory = (table, allowedColumns) ->
#       (data, args...) ->
#         query = table
#         index = 0
#         match.where.forEach (x) ->
#           condition = {}
#           condition[x] = args[index++]
#           query = query.where condition
#         if match.withConnection
#           connection = args[index]
#           unless connection?
#             throw new Error "#{name} must be called with connection as argument number #{index+1}"
#           query = query.setConnection connection
#         query
#           .allow(allowedColumns)
#           .update(data)
#
#     factory.$inject = [
#       options.nameToTable(match.name)
#       options.nameToAllowedColumns(match.name)
#     ]
#     factory.$source = 'autogenerated by fragments-forge.newDataUpdateResolver'
#     factory.$match = match
#
#     return {
#       factory: factory
#       name: name
#     }
#
#   resolver.$name = 'dataUpdateResolver'
#   return resolver

###################################################################################
# delete

  sources.parseDelete = (name) ->
    words = helfer.splitCamelcase name

    unless 'delete' is words[0]
      return

    [tableWhere, withConnection] = helfer.splitArrayWhereSequence(
      words.slice(1)
      ['with', 'connection']
    )

    [table, where...] = helfer.splitArrayWhereSequence tableWhere, 'where'

    if table.length is 0
      return

    # dont allow mass update without condition for security reasons
    if where.length is 0
      return

    {
      name: helfer.joinCamelcase table
      where: where.map (x) -> helfer.joinUnderscore x
      withConnection: withConnection?
    }

# module.exports.newDataDeleteResolver = (options = {}) ->
#   options.matcher ?= module.exports.parseDataDelete
#   options.nameToTable ?= (name) ->
#     name + 'Table'
#
#   resolver = (name, container, inner) ->
#     result = inner name
#     if result?
#       return result
#
#     match = options.matcher name
#     unless match?
#       return
#
#     factory = (table) ->
#       (args...) ->
#         query = table
#         index = 0
#         match.where.forEach (x) ->
#           condition = {}
#           condition[x] = args[index++]
#           query = query.where condition
#         if match.withConnection
#           connection = args[index]
#           unless connection?
#             throw new Error "#{name} must be called with connection as argument number #{index+1}"
#           query = query.setConnection connection
#         query.delete()
#
#     factory.$inject = [
#       options.nameToTable(match.name)
#     ]
#     factory.$source = 'autogenerated by fragments-forge.newDataDeleteResolver'
#     factory.$match = match
#
#     return {
#       factory: factory
#       name: name
#     }
#
#   resolver.$name = 'dataDeleteResolver'
#   return resolver

  return sources

module.exports = configure()
module.exports.configure = configure
