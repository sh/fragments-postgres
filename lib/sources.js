// Generated by CoffeeScript 1.9.2
var configure, helfer, optionsToConfig,
  slice = [].slice;

helfer = require('helfer');

optionsToConfig = function(options) {
  var config;
  config = {};
  config.tableWordArray = helfer.splitCamelcase(options.tableWords || 'table');
  config.nameToTable = options.nameToTable || function(name) {
    return helfer.joinCamelcase(helfer.splitCamelcase(name).concat(config.tableWordArray));
  };
  return config;
};

configure = function(options) {
  var config, sources;
  if (options == null) {
    options = {};
  }
  config = optionsToConfig(options);
  sources = {};
  sources.table = function(name) {
    var containsTable, doesntBeginWithTable, endsWithTable, factory, ref, ref1, results, tableName, words;
    words = helfer.splitCamelcase(name);
    results = helfer.splitArrayWhereSequence(words, config.tableWordArray);
    containsTable = results.length === 2;
    if (!containsTable) {
      return;
    }
    doesntBeginWithTable = ((ref = results[0]) != null ? ref.length : void 0) !== 0;
    if (!doesntBeginWithTable) {
      return;
    }
    endsWithTable = ((ref1 = results[1]) != null ? ref1.length : void 0) === 0;
    if (!endsWithTable) {
      return;
    }
    tableName = helfer.joinUnderscore(results[0]);
    factory = function(mesa) {
      return mesa.table(tableName);
    };
    factory.__inject = ['mesa'];
    factory.__source = 'generated by fragments-postgres.table';
    return factory;
  };
  sources.parseSelect = function(name) {
    var order, orderProcessed, ref, ref1, ref2, table, tableWhere, tableWhereOrder, tableWhereOrderConnection, type, where, whereProcessed, withConnection, words;
    words = helfer.splitCamelcase(name);
    type = words[0];
    if (type !== 'first' && type !== 'select') {
      return;
    }
    tableWhereOrderConnection = words.slice(1);
    ref = helfer.splitArrayWhereSequence(tableWhereOrderConnection, ['with', 'connection']), tableWhereOrder = ref[0], withConnection = ref[1];
    ref1 = helfer.splitArrayWhereSequence(tableWhereOrder, ['order', 'by']), tableWhere = ref1[0], order = 2 <= ref1.length ? slice.call(ref1, 1) : [];
    ref2 = helfer.splitArrayWhereSequence(tableWhere, 'where'), table = ref2[0], where = 2 <= ref2.length ? slice.call(ref2, 1) : [];
    if (table.length === 0) {
      return;
    }
    whereProcessed = where.filter(function(x) {
      return x.length !== 0;
    }).map(helfer.joinUnderscore);
    orderProcessed = order.filter(function(x) {
      return x.length !== 0;
    }).map(function(x) {
      var column, direction, last;
      last = x[x.length - 1];
      if (last === 'asc' || last === 'desc') {
        column = x.slice(0, -1);
        direction = last.toUpperCase();
      } else {
        column = x;
        direction = 'ASC';
      }
      return {
        column: helfer.joinUnderscore(column),
        direction: direction
      };
    });
    return {
      type: type,
      name: helfer.joinCamelcase(table),
      order: orderProcessed,
      where: whereProcessed,
      withConnection: withConnection != null
    };
  };
  sources.selectFirst = function(name) {
    var factory, parsed;
    parsed = sources.parseSelect(name);
    if (!((parsed != null) && parsed.type === 'first')) {
      return;
    }
    factory = function(table) {
      return function() {
        var args, connection, index, order, query;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        query = table;
        index = 0;
        parsed.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return query = query.where(condition);
        });
        if (parsed.order.length !== 0) {
          order = parsed.order.map(function(x) {
            return x.column + ' ' + x.direction;
          }).join(', ');
          query = query.order(order);
        }
        if (parsed.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          query = query.setConnection(connection);
        }
        return query.first();
      };
    };
    factory.__inject = [config.nameToTable(parsed.name)];
    factory.__source = 'generated by fragments-postgres.selectFirst';
    factory.__parsed = parsed;
    return factory;
  };
  sources.select = function(name) {
    var factory, parsed;
    parsed = sources.parseSelect(name);
    if (!((parsed != null) && parsed.type === 'select')) {
      return;
    }
    factory = function(table) {
      return function() {
        var args, connection, index, order, q;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        q = table;
        index = 0;
        parsed.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return q = q.where(condition);
        });
        if (parsed.order.length !== 0) {
          order = parsed.order.map(function(x) {
            return x.column + ' ' + x.direction;
          }).join(', ');
          q = q.order(order);
        }
        if (parsed.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          q = q.setConnection(connection);
        }
        return q.find();
      };
    };
    factory.__inject = [config.nameToTable(parsed.name)];
    factory.__source = 'generated by fragments-postgres.select';
    factory.__parsed = parsed;
    return factory;
  };
  sources.parseInsert = function(name) {
    var ref, table, withConnection, words;
    words = helfer.splitCamelcase(name);
    if ('insert' !== words[0]) {
      return;
    }
    ref = helfer.splitArrayWhereSequence(words.slice(1), ['with', 'connection']), table = ref[0], withConnection = ref[1];
    if (table.length === 0) {
      return;
    }
    return {
      name: helfer.joinCamelcase(table),
      withConnection: withConnection != null
    };
  };
  sources.parseUpdate = function(name) {
    var ref, ref1, table, tableWhere, where, withConnection, words;
    words = helfer.splitCamelcase(name);
    if ('update' !== words[0]) {
      return;
    }
    ref = helfer.splitArrayWhereSequence(words.slice(1), ['with', 'connection']), tableWhere = ref[0], withConnection = ref[1];
    ref1 = helfer.splitArrayWhereSequence(tableWhere, 'where'), table = ref1[0], where = 2 <= ref1.length ? slice.call(ref1, 1) : [];
    if (table.length === 0) {
      return;
    }
    if (where.length === 0) {
      return;
    }
    return {
      name: helfer.joinCamelcase(table),
      where: where.map(function(x) {
        return helfer.joinUnderscore(x);
      }),
      withConnection: withConnection != null
    };
  };
  sources.parseDelete = function(name) {
    var ref, ref1, table, tableWhere, where, withConnection, words;
    words = helfer.splitCamelcase(name);
    if ('delete' !== words[0]) {
      return;
    }
    ref = helfer.splitArrayWhereSequence(words.slice(1), ['with', 'connection']), tableWhere = ref[0], withConnection = ref[1];
    ref1 = helfer.splitArrayWhereSequence(tableWhere, 'where'), table = ref1[0], where = 2 <= ref1.length ? slice.call(ref1, 1) : [];
    if (table.length === 0) {
      return;
    }
    if (where.length === 0) {
      return;
    }
    return {
      name: helfer.joinCamelcase(table),
      where: where.map(function(x) {
        return helfer.joinUnderscore(x);
      }),
      withConnection: withConnection != null
    };
  };
  sources["delete"] = function(name) {
    var factory, parsed;
    parsed = sources.parseDelete(name);
    if (parsed == null) {
      return;
    }
    factory = function(table) {
      return function() {
        var args, connection, index, query;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        query = table;
        index = 0;
        parsed.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return query = query.where(condition);
        });
        if (parsed.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          query = query.setConnection(connection);
        }
        return query["delete"]();
      };
    };
    factory.__inject = [config.nameToTable(parsed.name)];
    factory.__source = 'generated by fragments-postgres.delete';
    factory.__parsed = parsed;
    return factory;
  };
  return sources;
};

module.exports = configure();

module.exports.configure = configure;
